**Задача 1**

Транзакции требуются в системах баз данных для обработки параллельных изменений. Транзакций можно избежать с помощью чисто поисковых приложений (только для чтения). Объясните, почему в приложениях, которые также выполняют операции по изменению, нельзя избежать транзакций для наших читателей. Приведите несколько примеров.

Без использования транзакций результат выполнения запроса может быть некорректным при нарушениях работы базы данных.

Пример:

UPDATE user\_account SET allsum=allsum + 2000 WHERE id='Bob'; 

UPDATE user\_account SET allsum=allsum - 2000 WHERE id='Alice'; 

При переводе денег одного пользователя другому при нарушении работы базы данных второй запрос может просто не выполниться, и деньги пользователю ‘Alice’ не придут. Это исключено при использовании транзакций – тогда либо деньги переведутся, либо останутся у пользователя ‘Bob’.

**Задача 2**

Найдите все возможные истории транзакций T1 и T2 и укажите их свойства сериализуемости.

T1: 

Read (A); 

A: = A - N;

Write (A);

Read (B);

B: = B + N;

Write (B);

T2: Read (A);

A: = A + M;

Write (A);

Перечислим все возможные транзакции:

1. r1(A), w1(A), r1(B), w1(B), r2(A), w2(A)
1. r1(A), w1(A), r1(B), r2(A), w2(A), w1(B)
1. r1(A), w1(A), r2(A), w2(A), r1(B), w1(B) 
1. r1(A), r2(A), w2(A), w1(A), r1(B), w1(B) 
1. r2(A), w2(A), r1(A), w1(A), r1(B), w1(B)
1. r1(A), w1(A), r1(B), r2(A), w1(B), w2(A)
1. r1(A), w1(A), r2(A), r1(B), w2(A), w1(B)
1. r1(A), r2(A), w1(A), w2(A), r1(B), w1(B) 
1. r2(A), r1(A), w2(A), w1(A), r1(B), w1(B)
1. r1(A), w1(A), r2(A), r1(B), w1(B), w2(A)
1. r1(A), r2(A), w1(A), r1(B), w2(A), w1(B)
1. r2(A), r1(A), w1(A), w2(A), r1(B), w1(B)
1. r1(A), r2(A), w1(A), r1(B), w1(B), w2(A) 
1. r2(A), r1(A), w1(A), r1(B), w2(A), w1(B)
1. r2(A), r1(A), w1(A), r1(B), w1(B), w2(A)

Все транзакции, кроме 1, 2, 3, 5, 6, 7 и 10 – не сериализуемы.

**Задача 3**

Исследуйте транзакции T1, T2, T3, T4, выполняя операции над объектами A, B, C, D, E. Рассмотрим следующие истории:

- H1) r1(A) r2(B) r3(B) r3(C) w2(A) r2(D) r1(A) w1(B) w2(D) r1(A) w2(C) w2(B) r2(B) w3(B) r2(B) c2 w4(C) r4(C) w4(A) c1 c4 c3
- H2) r1(A) r2(C) w3(D) w1(A) r1(D) w2(A) r2(B) r2(C) w2(B) w3(C) r2(A) w1(B) r1(B) r3(D) w1(B) c1 r3(B) c2 c3
- H3) r1(E) r2(B) r2(A) w2(B) w2(A) w1(B) r2(D) r2(E) r3(E) r2(A) r2(C) w2(A) w2(D) r1(A) w2(C) w1(A) r1(C) r2(E) r3(D) r1(A) w3(D) w1(A) r3(A) w1(C) r3(A) w1(B) r3(C) r3(B) r3(C) w3(A) c1 c2 c3
- H4) r3(A) r2(C) r1(B) w1(A) r1(C) r2(A) a1 w2(C) c2 r3(C) c3

Какие истории сериализуемы? Для каждой сериализуемой истории покажите эквивалентную последовательную историю. Как 2PL и изоляция снапшотов ведут себя в этой последовательности операций? Разрешены ли эти истории? Если да, существуют ли какие-либо возможные несоответствия с изоляцией снапшотов (snapshot)?

**Задача 4**

Можно ли сериализовать следующую историю? Если это так, укажите эквивалентную историю серий. Если нет, скажите, почему.

- T1: Select sum (money) from account;
- T2: Insert into account (account#, money) values (123, 0); commit
- T2: Commit;
- T1: Select avg (money) from account;
- T1: Commit;

Всего есть два варианта выполнения: {T1, T2} и {T2, T1}

{T1, T2}:

- T1: Select sum (money) from account;
- T1: Select avg (money) from account;
- T1: Commit;
- T2: Insert into account (account#, money) values (123, 0); commit
- T2: Commit;

Результат T1: Select avg (money) from account; будет отличаться -> серия не эквивалентна -> не подходит.

{T2, T1}:

- T2: Insert into account (account#, money) values (123, 0); commit
- T2: Commit;
- T1: Select sum (money) from account;
- T1: Select avg (money) from account;
- T1: Commit;

Сумма не будет отличаться т.к. добавляем 0, среднее не отличается, т.к. оно изначально вычисляется после добавления.


**Задача 5**

Объясните, почему ограничения целостности проверяются только в конце транзакции. Какие из свойств ACID требуются при таком подходе?

База данных может обладать такими ограничениями целостности, которые просто невозможно не нарушить, выполняя только один оператор изменения базы данных. Поэтому для поддержания подобных ограничений целостности допускается их нарушение внутри транзакции с тем условием, чтобы к моменту завершения транзакции условия целостности были соблюдены. При таком подходе необходима атомарность.

